---
title: 'Monday'
authors:
description:
type: '[[Journal]]'
created: 2025-12-15T11:33:43+01:00
modified: 2025-12-15T15:32:12+01:00
license:
license_url:
aliases:
  - 'Monday, December 15th, 2025'
  - 'Monday'
cssclasses:
  - 'Monday'
  - daily
long_title: 'Monday, December 15th, 2025'
places: '[[Home]]'
tags:
  - 'Monday'
  - daily
  - journal
---
 
## TODAY

_Monday, December 15th, 2025_

---

### Today I will accomplish

- [ ] database modeling for quality survey
    - [ ] admin dashboard uses workos for auth
    - [ ] listening_devices table containing hardware options
        - [ ] PK id\*
        - [ ] created_at\*
        - [ ] modified_at\*
        - [ ] approved_at (device is only listed globally if approved_at is non-null)
        - [ ] approved_by (admin_id)
        - [ ] device_type\* (enum: speaker(s) | headphones)
        - [ ] connection_type\* (enum: wired | bluetooth | wifi | ir)
        - [ ] brand\*
        - [ ] model\*
        - [ ] price_tier\* (enum: budget | mid | premium | flagship)
    - [ ] source_files table with original, lossless uploads
        - [ ] PK id\*
        - [ ] r2_key (path)\*
        - [ ] uploaded_at\*
        - [ ] license_url\* (link to generic license terms, or proof of license to me or uploader AND me that covers usage in the manner of this research project)
        - [ ] approved_at (audio is only included if approved_at is non-null)
        - [ ] approved_by (admin_id)
        - [ ] title\*
        - [ ] stream_url
        - [ ] artist
        - [ ] artist_url
        - [ ] genre
    - [ ] candidate_files table with entries for every (configured) permutation of codec+bitrate for any source_file
        - [ ] PK id\*
        - [ ] r2_key (path)\*
        - [ ] codec\* (enum: flac | opus | aac | mp3)
        - [ ] bitrate (integer, 0 for lossless)
        - [ ] source_file_id (FK source_files)
        - [ ] FK(`codec`,`bitrate`) from quality_options
    - [ ] quality_options table with codec+bitrate permutations
        - [ ] codec\* (enum: flac | opus | aac | mp3)
        - [ ] bitrate\* (integer, 0 for lossless)
        - [ ] enabled\* (whether to use this permutation in testing)
        - [ ] PK(`codec`,`bitrate`) (composite key)
    - [ ] ephemeral_stream_urls table acting as a lookup table to resolve candidate files and codec permutations upon submission
        - [ ] PK token\* to permit streaming of the candidate_file
        - [ ] candidate_file_id\* (FK candidate_files)
        - [ ] expires_at\* datetime after which this stream url is no longer valid. ensures that if the entry was never resolved (an answer never submitted), that the audio file cannot be downloaded from this stream link after a certain datetime. if the stream url is requested after the expires_at datetime, the row is deleted.
    - [ ] answers table
        - [ ] PK id\*
        - [ ] created_at\*
        - [ ] device_id\* (FK listening_devices)
        - [ ] candidate_a_id\*
        - [ ] candidate_b_id\*
        - [ ] selected (enum: a | b | neither)\*
        - [ ] comparison_type (enum: same_gapless | same_gap | different_gapless | different_gap)\*
        - [ ] response_time (integer, time spent deciding in ms)
    - [ ] result_snapshots table
        - [ ] PK created_at\*
        - [ ] expires_at\*
        - [ ] total_responses\*
        - [ ] assorted insight columns, may be expanded on in future with migrations or something...
- [ ] make sure snapshots are created with a queueing system to avoid race conditions / PK collisions.
- [ ] data visualizations
- [ ] deploy said database on d1

> [!todo] Due today from other sources
> 
> ```tasks
> filter by function											\
> 	const { due, happens, file } = task;						\
> 	if (file.path === "{{query.file.path}}") return false;		\
> 	if (due.moment && due.moment.isBefore(moment(), "day")) {	\
> 		return !task.isDone;									\
> 	}															\
> 	if (happens.moment && !file.path.includes("06 - Daily")) {	\
> 		return happens.moment.isSame(							\
> 			moment(												\
> 				"{{query.file.filenameWithoutExtension}}",		\
> 				"YYYY-MM-DD"									\
> 			),													\
> 			"day"												\
> 		);														\
> 	}															\
> 	return false;
>
> group by function 											\
> 	const {happens} = task;										\
> 	if (happens.moment.isBefore(moment(), 'day')) {				\
> 		return "%%1%% OVERDUE";									\
> 	}															\
> 	return "%%2%% Due Today";
> ```

> [!summary]- Other tasks this week
> 
> ```tasks
> path does not include {{query.file.path}}
> not done
> status.name does not include Rescheduled
> filter by function task.happens.moment?.isSame(moment('{{query.file.filenameWithoutExtension}}'), 'week') || false
> group by function                                 \
>   const date = task.happens;                      \
>   const file = task.file;                         \
>   if (!date.moment) {                             \
>     return "Undated";                             \
>   }                                               \
>   if (date.moment.day() === 0) {                  \
>     {{! Put the Sunday group last: }}             \
>     return date.format("[%%][8][%%]dddd");               \
>   }                                               \
>   if (date.moment.format("YYYY[-W]ww") === file.filenameWithoutExtension) { \
>     {{! Put the Today group as "This week": }}    \
>     return "This Week";                           \
>   }                                               \
>   return date.format("[%%]d[%%]dddd");
> ```

#### Yesterday I accomplished

%% TODO %%

---

### Journal

_Thoughts and scribbles…_  
%% TODO: Meta Bind form with basic "how was your day" questions %%

---

### Productivity Log

_My activity today…_

#### Pomodoro's

```dataviewjs
const page = dv.page('Pomodoro')

dv.table(
    ['Pomo', 'Time', 'Duration', 'Task'],
    page.file.lists
        .filter((item) => item?.pomodoro ?? false)
        .filter((item) =>
            moment(item?.begin, "YYYY-MM-DD'T'HH:mm:ss.SSSZ").isSame(
                moment(dv.current().file.name),
                'day'
            )
        )
        .map((item) => {
            return [
                item.pomodoro,
                moment(item.begin, "YYYY-MM-DD'T'HH:mm:ss.SSSZ").format(
                    'HH:mm:ss'
                ),
                item.duration,
                item.focused,
            ]
        })
)
```

#### Notes created today

%% TODO %%

#### Notes last edited today

%% TODO %%
